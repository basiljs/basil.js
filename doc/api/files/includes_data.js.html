<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>includes&#x2F;data.js - basil.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="basil.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: see header basil.js</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/b.html">b</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: includes&#x2F;data.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; ----------------------------------------
&#x2F;&#x2F; Data

pub.JSON = {
  &#x2F;**
   * Function parses and validates a string as JSON-object. Usage:
   * var obj = b.JSON.decode(str);
   * var str = b.JSON.encode(obj);
   * 
   * @cat Data
   * @subcat JSON
   * @method JSON.decode
   * @param  {String} String to be parsed as JSON-object.
   * @return {Object} Returns JSON-object or throws an error if invalid JSON has been provided.
  *&#x2F;
  &#x2F;&#x2F; From: jQuery JavaScript Library v1.7.1 http:&#x2F;&#x2F;jquery.com&#x2F;
  decode: function(data) {
    if ( typeof data !== &quot;string&quot; || !data ) {
      return null;
    }
    var rvalidchars = &#x2F;^[\],:{}\s]*$&#x2F;,
      rvalidescape = &#x2F;\\(?:[&quot;\\\&#x2F;bfnrt]|u[0-9a-fA-F]{4})&#x2F;g,
      rvalidtokens = &#x2F;&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?&#x2F;g,
      rvalidbraces = &#x2F;(?:^|:|,)(?:\s*\[)+&#x2F;g;

    &#x2F;&#x2F; Make sure the incoming data is actual JSON
    &#x2F;&#x2F; Logic borrowed from http:&#x2F;&#x2F;json.org&#x2F;json2.js
    if ( rvalidchars.test( data.replace( rvalidescape, &quot;@&quot; )
      .replace( rvalidtokens, &quot;]&quot; )
      .replace( rvalidbraces, &quot;&quot;)) ) {
      return ( new Function( &quot;return &quot; + data ) )();
    }
    error( &quot;b.JSON.decode(), invalid JSON: &quot; + data );
  },
  &#x2F;**
   * Function convert an javascript object to a JSON-string. Usage:
   * var str = b.JSON.encode(obj);
   * var obj = b.JSON.decode(str);
   *
   * @cat Data
   * @subcat JSON
   * @method JSON.encode
   * @param  {Object} Object to be converted to a JSON-string
   * @return {String} Returns JSON-string
   *&#x2F;
  &#x2F;&#x2F; From: https:&#x2F;&#x2F;gist.github.com&#x2F;754454
  encode: function(obj) {
    var t = typeof (obj);
    if (t !== &quot;object&quot; || obj === null) {
      &#x2F;&#x2F; simple data type
      if (t === &quot;string&quot;) obj = &#x27;&quot;&#x27; + obj + &#x27;&quot;&#x27;;
      return String(obj);
    } else {
      &#x2F;&#x2F; recurse array or object
      var n, v, json = [], arr = (obj &amp;&amp; obj.constructor === Array);

      for (n in obj) {
        v = obj[n];
        t = typeof(v);
        if (obj.hasOwnProperty(n)) {
          if (t === &quot;string&quot;) v = &#x27;&quot;&#x27; + v + &#x27;&quot;&#x27;; else if (t === &quot;object&quot; &amp;&amp; v !== null) v = pub.JSON.encode(v);
          json.push((arr ? &quot;&quot; : &#x27;&quot;&#x27; + n + &#x27;&quot;:&#x27;) + String(v));
        }
      }
      return (arr ? &quot;[&quot; : &quot;{&quot;) + String(json) + (arr ? &quot;]&quot; : &quot;}&quot;);
    }
  }
};

&#x2F;&#x2F; Taken and hijacked from d3.js robust csv parser. Hopefully Michael Bostock won&#x27;t mind.
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mbostock&#x2F;d3&#x2F;tree&#x2F;master&#x2F;src&#x2F;dsv
pub.CSV = new CSV();
function CSV() {
  var reParse = null, 
      reFormat = null,
      delimiterStr = null,
      delimiterCode = null;

  initDelimiter(&#x27;,&#x27;);
  function initDelimiter(delimiter) {
    reParse = new RegExp(&quot;\r\n|[&quot; + delimiter + &quot;\r\n]&quot;, &quot;g&quot;), &#x2F;&#x2F; field separator regex
    reFormat = new RegExp(&quot;[\&quot;&quot; + delimiter + &quot;\n]&quot;),
    delimiterCode = delimiter.charCodeAt(0);
    delimiterStr = delimiter;
  };

  &#x2F;**
   * Sets the delimiter of the CSV decode and encode function.
   * 
   * @cat Data
   * @subcat CSV
   * @method CSV.delimiter
   * @param  {String} [delimiter] Optional Sets the delimiter for CSV parsing
   * @return {String} Returns the current delimiter if called without argument
  *&#x2F;
  this.delimiter = function(delimiter) {
    if (arguments.length === 0) return delimiterStr;
    if (typeof delimiter === &#x27;string&#x27;) {
      initDelimiter(delimiter);
    } else {
      error(&quot;b.CSV.delimiter, separator has to be a character or string&quot;);
    }
  };

  &#x2F;**
   * Function parses a string as CSV-object Array. Usage:
   * var arr = b.CSV.decode(str);
   * var str = b.CSV.encode(arr);
   * 
   * @cat Data
   * @subcat CSV
   * @method CSV.decode
   * @param  {String} String to be parsed as CSV-object.
   * @return {Array} Returns CSV-object Array
  *&#x2F;
  this.decode = function(text) {
    var header;
    return parseRows(text, function(row, i) {
      if (i) {
        var o = {}, j = -1, m = header.length;
        while (++j &lt; m) o[header[j]] = row[j];
        return o;
      } else {
        header = row;
        return null;
      }
    });
  };

  &#x2F;**
   * Function convert an javascript array of objects to a CSV-string. Usage:
   * var str = b.CSV.encode(arr);
   * var arr = b.CSV.decode(str);
   *
   * @cat Data
   * @subcat CSV
   * @method CSV.encode
   * @param  {Array} Array to be converted to a CSV-string
   * @return {String} Returns CSV-string
   *&#x2F;
  this.encode = function(rows) {
    var csvStrings = [];
    var header = [];
    var firstRow = rows[0]; &#x2F;&#x2F; all rows have to have the same properties keys
    &#x2F;&#x2F; gather infos for the header
    for (var propname in firstRow) {
      if (firstRow.hasOwnProperty(propname)) {
        header.push(propname);
      };
    };
    csvStrings.push( formatRow(header) );
    for (var i = 0; i &lt; rows.length; i++) {
      var row = rows[i];
      var tokens = [];
      for (var ii = 0; ii &lt; header.length; ii++) {
        tokens.push(row[header[ii]]);
      };
      csvStrings.push( formatRow(tokens) );
    };
    return csvStrings.join(&quot;\n&quot;);
  };

  function formatRow(row) {
    return row.map(formatValue).join(delimiterStr);
  }

  function formatValue(text) {
    return reFormat.test(text) ? &quot;\&quot;&quot; + text.replace(&#x2F;\&quot;&#x2F;g, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot; : text;
  }

  function parseRows(text, f) {
    var EOL = {}, &#x2F;&#x2F; sentinel value for end-of-line
        EOF = {}, &#x2F;&#x2F; sentinel value for end-of-file
        rows = [], &#x2F;&#x2F; output rows
        n = 0, &#x2F;&#x2F; the current line number
        t, &#x2F;&#x2F; the current token
        eol; &#x2F;&#x2F; is the current token followed by EOL?

    reParse.lastIndex = 0; &#x2F;&#x2F; work-around bug in FF 3.6

    function token() {
      if (reParse.lastIndex &gt;= text.length) return EOF; &#x2F;&#x2F; special case: end of file
      if (eol) { eol = false; return EOL; } &#x2F;&#x2F; special case: end of line

      &#x2F;&#x2F; special case: quotes
      var j = reParse.lastIndex;
      if (text.charCodeAt(j) === 34) {
        var i = j;
        while (i++ &lt; text.length) {
          if (text.charCodeAt(i) === 34) {
            if (text.charCodeAt(i + 1) !== 34) break;
            i++;
          }
        }
        reParse.lastIndex = i + 2;
        var c = text.charCodeAt(i + 1);
        if (c === 13) {
          eol = true;
          if (text.charCodeAt(i + 2) === 10) reParse.lastIndex++;
        } else if (c === 10) {
          eol = true;
        }
        return text.substring(j + 1, i).replace(&#x2F;&quot;&quot;&#x2F;g, &quot;\&quot;&quot;);
      }

      &#x2F;&#x2F; common case
      var m = reParse.exec(text);
      if (m) {
        eol = m[0].charCodeAt(0) !== delimiterCode;
        return text.substring(j, m.index);
      }
      reParse.lastIndex = text.length;
      return text.substring(j);
    }

    while ((t = token()) !== EOF) {
      var a = [];
      while (t !== EOL &amp;&amp; t !== EOF) {
        a.push(t);
        t = token();
      }
      if (f &amp;&amp; !(a = f(a, n++))) continue;
      rows.push(a);
    }

    return rows;
  };
};

&#x2F;&#x2F; -- Conversion --

&#x2F;**  @class b *&#x2F;

&#x2F;**
 * Converts a byte, char, int, or color to a String containing the
 * equivalent binary notation. For example color(0, 102, 153, 255) 
 * will convert to the String &quot;11111111000000000110011010011001&quot;. This 
 * function can help make your geeky debugging sessions much happier.
 *
 
 * @cat Data
 * @subcat Conversion
 * @method binary
 * @param {Number} num value to convert
 * @param {Number} [numBits] number of digits to return
 * @return {String} A formatted string
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;binary_&#x2F;
pub.binary = function(num, numBits) {
  var bit;
  if (numBits &gt; 0) bit = numBits;
  else if (num instanceof Char) {
    bit = 16;
    num |= 0;
  } else {
    bit = 32;
    while (bit &gt; 1 &amp;&amp; !(num &gt;&gt;&gt; bit - 1 &amp; 1)) bit--;
  }
  var result = &quot;&quot;;
  while (bit &gt; 0) result += num &gt;&gt;&gt; --bit &amp; 1 ? &quot;1&quot; : &quot;0&quot;;
  return result;
};

&#x2F;** 
 * Converts a String representation of a binary number to its 
 * equivalent integer value. For example, unbinary(&quot;00001000&quot;) will 
 * return 8.
 *
 * @cat Data
 * @subcat Conversion
 * @method unbinary
 * @param {String} binaryString value to convert
 * @return {Number} The integer representation
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;unbinary_&#x2F;
pub.unbinary = function(binaryString) {
  var i = binaryString.length - 1,
    mask = 1,
    result = 0;
  while (i &gt;= 0) {
    var ch = binaryString[i--];
    if (ch !== &quot;0&quot; &amp;&amp; ch !== &quot;1&quot;) throw &quot;the value passed into unbinary was not an 8 bit binary number&quot;;
    if (ch === &quot;1&quot;) result += mask;
    mask &lt;&lt;= 1;
  }
  return result;
};


var decimalToHex = function(d, padding) {
  padding = padding === undef || padding === null ? padding = 8 : padding;
  if (d &lt; 0) d = 4294967295 + d + 1;
  var hex = Number(d).toString(16).toUpperCase();
  while (hex.length &lt; padding) hex = &quot;0&quot; + hex;
  if (hex.length &gt;= padding) hex = hex.substring(hex.length - padding, hex.length);
  return hex;
};

&#x2F;**
 * Convert a number to a hex representation. 
 *
 * @cat Data
 * @subcat Conversion
 * @method hex
 * @param {Number} value The number to convert
 * @param {Number} [len] The length of the hex number to be created, default: 8
 * @return {String} The hex representation as a string
 *&#x2F;
pub.hex = function(value, len) {
  if (arguments.length === 1) len = 8;
  return decimalToHex(value, len);
};

var unhexScalar = function(hex) {
  var value = parseInt(&quot;0x&quot; + hex, 16);
  if (value &gt; 2147483647) value -= 4294967296;
  return value;
}

&#x2F;**
 * Convert a hex representation to a number.
 *
 * @cat Data
 * @subcat Conversion
 * @method unhex
 * @param {String} hex The hex representation
 * @return {Number} The number
 *&#x2F;
pub.unhex = function(hex) {
  if (hex instanceof Array) {
    var arr = [];
    for (var i = 0; i &lt; hex.length; i++) arr.push(unhexScalar(hex[i]));
    return arr;
  }
  return unhexScalar(hex);
};


&#x2F;&#x2F; -- String Functions --



&#x2F;**
 * Removes multiple, leading or trailing spaces and punctuation from &quot;words&quot;. E.g. converts &quot;word!&quot; to &quot;word&quot;. Especially useful together with b.words();
 * 
 * @method trimWord
 * @cat Data
 * @subcat String Functions
 * @param {String} s The String to trim
 * @param
 *&#x2F;
 &#x2F;&#x2F; from: http:&#x2F;&#x2F;www.qodo.co.uk&#x2F;blog&#x2F;javascript-trim-leading-and-trailing-spaces&#x2F;
pub.trimWord = function(s) { 
    s = s.replace(&#x2F;(^[,.!?-]*)|([-,.!?]*$)&#x2F;gi,&quot;&quot;);
    s = s.replace(&#x2F;\s*&#x2F;gi,&quot;&quot;);
&#x2F;&#x2F;    s = s.replace(&#x2F;[ ]{2,}&#x2F;gi,&quot; &quot;); 
    s = s.replace(&#x2F;\n*&#x2F;,&quot;&quot;);     
    return s;
};

&#x2F;**
 * Combines an array of Strings into one String, each separated by 
 * the character(s) used for the separator parameter. To join arrays 
 * of ints or floats, it&#x27;s necessary to first convert them to strings 
 * using nf() or nfs().
 *
 * @method join
 * @cat Data
 * @subcat String Functions
 * @param {Array} array A string array
 * @param {String} separator The separator to be inserted
 * @return {String} The joined string
 *&#x2F;
 &#x2F;&#x2F; http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;join_&#x2F;
pub.join = function(array, separator) {
  return array.join(separator);
};

&#x2F;**
 * The split() function breaks a string into pieces using a
 * character or string as the divider. The delim parameter specifies the
 * character or characters that mark the boundaries between each piece. A
 * String[] array is returned that contains each of the pieces.
 *
 * If the result is a set of numbers, you can convert the String[] array
 * to to a float[] or int[] array using the datatype conversion functions
 * int() and float() (see example above).
 *
 * The splitTokens() function works in a similar fashion, except that it
 * splits using a range of characters instead of a specific character or
 * sequence.    
 *  
 * @cat Data
 * @subcat String Functions
 * @method split
 * @param {String} str the String to be split
 * @param {String} [delim] The string used to separate the data
 * @return {Array} Array of strings
 *&#x2F;
 &#x2F;&#x2F; http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;split_&#x2F;
pub.split = function(str, delim) {     
  return str.split(delim);   
};

&#x2F;**
 * The splitTokens() function splits a String at one or many character 
 * &quot;tokens.&quot; The tokens parameter specifies the character or characters 
 * to be used as a boundary.
 *
 * If no tokens character is specified, any whitespace character is used 
 * to split. Whitespace characters include tab (\t), line feed (\n), 
 * carriage return (\r), form feed (\f), and space. To convert a String 
 * to an array of integers or floats, use the datatype conversion functions 
 * int() and float() to convert the array of Strings.
 *  
 * @cat Data
 * @subcat String Functions
 * @method splitTokens
 * @param {String} str the String to be split
 * @param {String} [tokens] list of individual characters that will be used as separators
 * @return {Array} Array of strings
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;splitTokens_&#x2F;
pub.splitTokens = function(str, tokens) {
  if (arguments.length === 1) tokens = &quot;\n\t\r\u000c &quot;;
  tokens = &quot;[&quot; + tokens + &quot;]&quot;;
  var ary = [];
  var index = 0;
  var pos = str.search(tokens);
  while (pos &gt;= 0) {
    if (pos === 0) str = str.substring(1);
    else {
      ary[index] = str.substring(0, pos);
      index++;
      str = str.substring(pos);
    }
    pos = str.search(tokens);
  }
  if (str.length &gt; 0) ary[index] = str;
  if (ary.length === 0) ary = undef;
  return ary;
};  

&#x2F;* todo *&#x2F;
pub.match = function(str, regexp) {
  return str.match(regexp);
};

&#x2F;* todo *&#x2F;
pub.matchAll = function(aString, aRegExp) {
  var results = [],
    latest;
  var regexp = new RegExp(aRegExp, &quot;g&quot;);
  while ((latest = regexp.exec(aString)) !== null) {
    results.push(latest);
    if (latest[0].length === 0)++regexp.lastIndex;
  }
  return results.length &gt; 0 ? results : null;
};

function nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group) {
  var sign = value &lt; 0 ? minus : plus;
  var autoDetectDecimals = rightDigits === 0;
  var rightDigitsOfDefault = rightDigits === undef || rightDigits &lt; 0 ? 0 : rightDigits;
  var absValue = Math.abs(value);
  if (autoDetectDecimals) {
    rightDigitsOfDefault = 1;
    absValue *= 10;
    while (Math.abs(Math.round(absValue) - absValue) &gt; 1.0E-6 &amp;&amp; rightDigitsOfDefault &lt; 7) {
      ++rightDigitsOfDefault;
      absValue *= 10;
    }
  } else if (rightDigitsOfDefault !== 0) absValue *= Math.pow(10, rightDigitsOfDefault);
  var number, doubled = absValue * 2;
  if (Math.floor(absValue) === absValue) number = absValue;
  else if (Math.floor(doubled) === doubled) {
    var floored = Math.floor(absValue);
    number = floored + floored % 2;
  } else number = Math.round(absValue);
  var buffer = &quot;&quot;;
  var totalDigits = leftDigits + rightDigitsOfDefault;
  while (totalDigits &gt; 0 || number &gt; 0) {
    totalDigits--;
    buffer = &quot;&quot; + number % 10 + buffer;
    number = Math.floor(number &#x2F; 10);
  }
  if (group !== undef) {
    var i = buffer.length - 3 - rightDigitsOfDefault;
    while (i &gt; 0) {
      buffer = buffer.substring(0, i) + group + buffer.substring(i);
      i -= 3;
    }
  }
  if (rightDigitsOfDefault &gt; 0) return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) + &quot;.&quot; + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);
  return sign + buffer;
}
function nfCore(value, plus, minus, leftDigits, rightDigits, group) {
  if (value instanceof Array) {
    var arr = [];
    for (var i = 0, len = value.length; i &lt; len; i++) arr.push(nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));
    return arr;
  }
  return nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);
}

&#x2F;**    
 * Utility function for formatting numbers into strings. There
 * are two versions, one for formatting floats and one for formatting
 * ints. The values for the digits, left, and right parameters should
 * always be positive integers.

 * As shown in the above example, nf() is used to add zeros to the
 * left and&#x2F;or right of a number. This is typically for aligning a list
 * of numbers. To remove digits from a floating-point number, use the
 * int(), ceil(), floor(), or round() functions.    
 * 
 * @cat Data
 * @subcat String Functions
 * @method nf
 * @param {Number} value The Number to convert
 * @param {Number} leftDigits
 * @param {Number} rightDigits   
 * @return {String} The formatted string
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nf_&#x2F;
pub.nf = function(value, leftDigits, rightDigits) {
  return nfCore(value, &quot;&quot;, &quot;-&quot;, leftDigits, rightDigits);
};

&#x2F;**    
 * Utility function for formatting numbers into strings. Similar to nf() 
 * but leaves a blank space in front of positive numbers so they align 
 * with negative numbers in spite of the minus symbol. There are two 
 * versions, one for formatting floats and one for formatting ints. The 
 * values for the digits, left, and right parameters should always be 
 * positive integers.   
 * 
 * @cat Data
 * @subcat String Functions
 * @method nfs
 * @param {Number} value The Number to convert
 * @param {Number} leftDigits
 * @param {Number} rightDigits   
 * @return {String} The formatted string
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nfs_&#x2F;
pub.nfs = function(value, leftDigits, rightDigits) {
  return nfCore(value, &quot; &quot;, &quot;-&quot;, leftDigits, rightDigits);
};

&#x2F;**    
 * Utility function for formatting numbers into strings. Similar to nf() 
 * but puts a &quot;+&quot; in front of positive numbers and a &quot;-&quot; in front of 
 * negative numbers. There are two versions, one for formatting floats 
 * and one for formatting ints. The values for the digits, left, and right 
 * parameters should always be positive integers.      
 * 
 * @cat Data
 * @subcat String Functions
 * @method nfp
 * @param {Number} value The Number to convert
 * @param {Number} leftDigits
 * @param {Number} rightDigits   
 * @return {String} The formatted string
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nfp_&#x2F;
pub.nfp = function(value, leftDigits, rightDigits) {
  return nfCore(value, &quot;+&quot;, &quot;-&quot;, leftDigits, rightDigits);
};

&#x2F;**    
 * Utility function for formatting numbers into strings and placing 
 * appropriate commas to mark units of 1000. There are two versions, one 
 * for formatting ints and one for formatting an array of ints. The value 
 * for the digits parameter should always be a positive integer.     
 * 
 * @cat Data
 * @subcat String Functions
 * @method nfc
 * @param {Number} value The Number to convert
 * @param {Number} leftDigits
 * @param {Number} rightDigits   
 * @return {String} The formatted string
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;nfc_&#x2F;
pub.nfc = function(value, leftDigits, rightDigits) {
  return nfCore(value, &quot;&quot;, &quot;-&quot;, leftDigits, rightDigits, &quot;,&quot;);
};


&#x2F;**    
 * Removes whitespace characters from the beginning and end of a String. 
 * In addition to standard whitespace characters such as space, carriage 
 * return, and tab, this function also removes the Unicode &quot;nbsp&quot; character.    
 * 
 * @cat Data
 * @subcat String Functions
 * @method trim
 * @param {String|Array} str A string or an array of strings to be trimmed
 * @return {String|Array} Returns the input in a trimmed way
 *&#x2F;
 &#x2F;&#x2F; From: http:&#x2F;&#x2F;processingjs.org&#x2F;reference&#x2F;trim_&#x2F;
pub.trim = function(str) {
  if (str instanceof Array) {
    var arr = [];
    for (var i = 0; i &lt; str.length; i++) arr.push(str[i].replace(&#x2F;^\s*&#x2F;, &quot;&quot;).replace(&#x2F;\s*$&#x2F;, &quot;&quot;).replace(&#x2F;\r*$&#x2F;, &quot;&quot;));
    return arr;
  }
  return str.replace(&#x2F;^\s*&#x2F;, &quot;&quot;).replace(&#x2F;\s*$&#x2F;, &quot;&quot;).replace(&#x2F;\r*$&#x2F;, &quot;&quot;);
};

&#x2F;**    
 * Checks whether an URL string is valid.    
 * 
 * @cat Data
 * @subcat String Functions
 * @method isURL
 * @param {String} url An url string to be checked
 * @return {Boolean} Returns either true or false
 *&#x2F;
var isURL = pub.isURL = function(url) {
  var pattern = &#x2F;(ftp|http|https):\&#x2F;\&#x2F;(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\&#x2F;|\&#x2F;([\w#!:.?+=&amp;%@!\-\&#x2F;]))?&#x2F;;
  return pattern.test(url);
};

&#x2F;**    
 * Checks whether a string ends with a specific character or string.    
 * 
 * @cat Data
 * @subcat String Functions
 * @method endsWith
 * @param {String} str A string to be checked
 * @return {Boolean} Returns either true or false
 *&#x2F;
var endsWith = pub.endsWith = function(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
};

&#x2F;**    
 * Checks whether a string starts with a specific character or string.    
 * 
 * @cat Data
 * @subcat String Functions
 * @method startsWith
 * @param {String} str A string to be checked
 * @return {Boolean} Returns either true or false
 *&#x2F;
var startsWith = pub.startsWith = function(str, prefix) {
  return str.indexOf(prefix) === 0;
};


&#x2F;**
 * Checks whether a var is an Array, returns true if this is the case
 *
 * @cat Data
 * @subcat Type-Check
 * @method isArray
 * @param  {Object|String|Number|Boolean} obj The object to check
 * @return {Boolean} returns true if this is the case
 *&#x2F;
var isArray = pub.isArray = function(obj) {
  return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;;
};

&#x2F;**
 * Checks whether a var is a number, returns true if this is the case
 *
 * @cat Data
 * @subcat Type-Check
 * @method isNumber
 * @param  {Object|String|Number|Boolean}  num The number to check
 * @return {Boolean} returns true if this is the case
 *&#x2F;
var isNumber = pub.isNumber = function(num) {
  return !isNaN(parseFloat(num)) &amp;&amp; isFinite(num);
};

&#x2F;**
 * Checks whether a var is a string, returns true if this is the case
 *
 * @cat Data
 * @subcat Type-Check
 * @method isString
 * @param  {Object|String|Number|Boolean} str The string to check
 * @return {Boolean} returns true if this is the case
 *&#x2F;
var isString = pub.isString = function(str) {
  return Object.prototype.toString.call(str) === &#x27;[object String]&#x27;;
};

&#x2F;**
 * Checks whether a var is an indesign text object, returns true if this is the case
 * NB: a indesign TextFrame will return false as it is just a container holding text. 
 * So you could say that isText() refers to all the things inside a TextFrame.
 *
 * @cat Document
 * @subcat Type-Check
 * @method isText
 * @param  {Character|InsertionPoint|Line|Paragraph|TextColumn|TextStyleRange|Word}  obj The object to check
 * @return {Boolean} returns true if this is the case
 *&#x2F;
var isText = pub.isText = function(obj) {
  return obj instanceof Character ||
         obj instanceof InsertionPoint ||
         obj instanceof Line ||
         obj instanceof Paragraph ||
         obj instanceof TextColumn ||
         obj instanceof TextStyleRange ||
         obj instanceof Word;
};


var initDataFile = function(file, mustExist) {
  var result = null;
  if (file instanceof File) {
    result = file;
  } else {
    var folder = new Folder(projectPath().absoluteURI + &#x27;&#x2F;data&#x27;);
    folder.create(); &#x2F;&#x2F; creates data folder if not existing, otherwise it just skips
    result = new File(folder.absoluteURI + &#x27;&#x2F;&#x27; + file);
  }
  if (mustExist &amp;&amp; !result.exists) {
    error(&#x27;The file &quot;&#x27; + result + &#x27;&quot; does not exist.&#x27;);
  }
  return result;
};

var initExportFile = function(file, mustExist) {
  var result = null;
  if (file instanceof File) {
    result = file;
  } else {

    &#x2F;&#x2F; get rid of some special cases the user might specify
    var pathNormalized = file.split(&quot;&#x2F;&quot;);
    for (var i = 0; i &lt; pathNormalized.length; i++) {
      if (pathNormalized[i] === &quot;&quot; || pathNormalized[i] === &quot;.&quot;) {
        pathNormalized.splice(i,1);
      };
    };

    var tmpPath = projectPath().absoluteURI;
    var fileName = pathNormalized[pathNormalized.length-1];
    
    &#x2F;&#x2F; contains the path folders? if so create them ...
    if (pathNormalized.length &gt; 1) {
      var folders = pathNormalized.slice(0,-1);
      for (var i = 0; i &lt; folders.length; i++) {
        tmpPath += &quot;&#x2F;&quot;+folders[i] 
        var f = new Folder(tmpPath);
        if (!f.exists) f.create();
      };
    } 

    &#x2F;&#x2F; result = new File(projectPath().absoluteURI + &#x27;&#x2F;&#x27; + file);
    result = new File(tmpPath + &#x27;&#x2F;&#x27; + fileName);
  }
  if (mustExist &amp;&amp; !result.exists) {
    error(&#x27;The file &quot;&#x27; + result + &#x27;&quot; does not exist.&#x27;);
  }
  return result;
};

&#x2F;**
 * Get the full path to the folder of the active document.
 *
 * @cat Document
 * @subcat Misc
 * @method projectPath
 * @return {File} The folder of the the active document
 *&#x2F;
var projectPath = pub.projectPath = function() {
  var docPath = null;
  try {
    docPath = currentDoc().filePath;
  } catch (e) {
    error(&quot;The current document must be saved before its project directory can be accessed.&quot;);
  }
  return docPath;
};


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
